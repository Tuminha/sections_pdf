# In this file we will only extract the results from the pdf extraction based on the xml file generated by grobid. 
import subprocess
import time
import xml.etree.ElementTree as ET
from typing import Any
import requests


# Path to the GROBID service
grobid_path = '/Users/franciscoteixeirabarbosa/projects/test/sections_pdf/grobid'


# First check if the GROBID service is already running, and if it already running do not start it again
# Check if the GROBID service is already running
try:
    response = requests.get('http://localhost:8070/api/isalive', timeout=10)
    if response.status_code == 200:
        print("GROBID service is already running.")
    else:
        # Start the GROBID service
        p = subprocess.Popen(['./gradlew', 'run', '--stacktrace'], cwd=grobid_path)
        # Wait for the GROBID service to start
        time.sleep(10)
except requests.exceptions.RequestException as e:
    # If the request fails, it means the service is not running
    print("GROBID service is not running. Starting it now...")
    p = subprocess.Popen(['./gradlew', 'run', '--stacktrace'], cwd=grobid_path)
    # Wait for the GROBID service to start
    time.sleep(10)

# Wait for the GROBID service to start
time.sleep(10)

PDF_PATH = (
    '/Users/franciscoteixeirabarbosa/projects/test/sections_pdf/data/Implant survival rates after osteotome_mediated maxillary sinus augmentation_ a systematic review.pdf'
)

# Send the PDF to GROBID
with open(PDF_PATH, 'rb') as f:
    response = requests.post('http://localhost:8070/api/processFulltextDocument', files={'input': f}, timeout=10)

# Save the XML output
with open('output.xml', 'w', encoding='utf-8') as f:
    f.write(response.text)

# Parse the XML output
tree = ET.parse('output.xml')
root = tree.getroot()

# Define the namespace
ns = {'tei': 'http://www.tei-c.org/ns/1.0'}

# Parse the XML file
tree = ET.parse('output.xml')
root = tree.getroot()

def extract_results(xml_root: ET.Element, namespace: dict) -> str:
    """
    This function extracts the results section from the XML root.

    Parameters:
    xml_root (ET.Element): The root of the XML document.
    namespace (dict): The namespace for the XML document.

    Returns:
    str: The results section as a string.
    """
    # Flag to indicate whether we are in the 'results' section
    in_results = False

    # Initialize an empty string to store the results
    results = ""

    # Find all 'div' elements in the XML
    for div in xml_root.findall('.//tei:div', namespace):
        # Get the title of the section
        title = div.find('tei:head', ns)
        if title is not None:
            title = title.text.strip().lower()  # Remove leading/trailing whitespace and convert to lower case

            # Check if the title contains 'results'
            if 'results' in title:
                results += 'Results section found:\n'
                in_results = True

            # If we are in the 'results' section and encounter a 'div' with 'discussion' or 'conclusion' in the title, stop appending
            if in_results and ('discussion' in title or 'conclusion' in title):
                break

        if in_results:
            # Append the title of the subsection
            if title and 'results' not in title:
                results += title + "\n"

            # Recursively find all 'p' elements in the 'div'
            paragraphs = div.findall('.//tei:p', ns)
            for paragraph in paragraphs:
                if paragraph is not None:  # Check if the paragraph exists
                    # Append the paragraph text
                    results += paragraph.text

                    # Append the text of any 'ref' elements within the paragraph
                    for ref in paragraph.findall('.//tei:ref', ns):
                        if ref.text:
                            results += ref.text

                    results += "\n"  # Add a newline after the paragraph

    # Return the results string
    return results

def extract_tables(xml_root: Any, namespace: Any) -> str:
    """
    This function extracts all tables from the XML root.

    Parameters:
    xml_root (Any): The root of the XML document.
    namespace (Any): The namespace for the XML document.

    Returns:
    str: The tables as a string.
    """
    # Initialize an empty string to store the tables
    tables = ""

    # Find all 'figure' elements in the XML
    for figure in xml_root.findall('.//tei:figure', namespace):
        table = figure.find('.//tei:table', ns)
        if table is not None:
            tables += "\nTable:\n"
            rows = table.findall('.//tei:row', ns)
            for row in rows:
                cells = [cell.text for cell in row.findall('.//tei:cell', ns) if cell.text]
                tables += '\t'.join(cells) + "\n"

    # Return the tables string
    return tables

# Call the functions and save the results in variables
results = extract_results(root, ns)
tables = extract_tables(root, ns)

# Collect all the results from the 3 functions above and save them in a variable that will be passed to 3_results_analysis.py so the AI can analyze the results
# In the variable it should collect the contents of the results of the 3 functions if it was able to collect any info
# If it was not able to collect any info it should return None
# The variable should be called results_for_ai  and it should be a string
# If the variable is None it should return None

# Combine the results and tables into a single string
results_for_ai = results + "\n" + tables

__all__ = ['results_for_ai']
